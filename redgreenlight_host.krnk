# Server Script runs only on Hosted server & not in test mode
# KrunkScript Copyright (C) Yendis Entertainment Pty Ltd
# 
# Add custom actions here

# ======================================================
# HOST KNOBS
num VEL_NOTMOVING = 0.01; # how fast can a player move before we start shooting it (pixels/ms)
num MS_FIRERATE = 1000; # how fast to shoot
num GUNDAMAGE = 200; # how much damage per shot



# Stage 1: Red/Green light
num MS_MINREDLIGHT = 2000;     num MS_MAXREDLIGHT = 2000;
num MS_MINGREENLIGHT = 1500;   num MS_MAXGREENLIGHT = 3000;
num MS_CLOCKTIMER = 50000; 
num MS_INTERVAL_CLOCKSYNC = 5000;

# Stage 2: honeycomb
obj honeycombstart = {x: -173, y: 100, z: 132};

# ======================================================

bool redlight = false;
obj[] ais = obj[];
obj doll = {};

str[] markedList = str[];
bool action playerisMarked(str username) {
    for (num i = 0; i < lengthOf markedList; i++) {
        if (markedList[i] == username) {
            return true;
        }
    }
    return false;
}

bool action removeMark(str username) {
    for (num i = 0; i < lengthOf markedList; i++) {
        if (markedList[i] == username) {
            remove markedList[i];
            return true;
        }
    }
    return false;
}

bool action addMarks(obj[] plrList) {
    bool marksAdded = false;
    for (num i=0; i < lengthOf plrList; i++) {
        obj player = plrList[i];
        
        if (playerinRange((str)player.id) && ((num)player.health > 0) && !playerisMarked((str)player.username) && 
        (((num)player.velocity.x > VEL_NOTMOVING) || ((num)player.velocity.y > VEL_NOTMOVING) || ((num)player.velocity.z > VEL_NOTMOVING))) {
            addTo markedList (str)player.username;
            GAME.NETWORK.send("marked",{},(str)player.id);
            marksAdded = true;
        }
    }
    return marksAdded;

}

str action findNearestPlayer(obj pos, str[] markedList, obj[] plrList){
    # find player in plrList
    num nearest = 9000;
    str plrid = "";
    for(num i=0; i< lengthOf markedList; i++) {
        for(num j=0; j < lengthOf plrList; j++) {
            if (markedList[i] == (str)plrList[j].username) {
                num dist = Math.abs(UTILS.getDist3D((num)pos.x,(num)pos.y,(num)pos.z,(num)plrList[j].position.x,(num)plrList[j].position.y,(num)plrList[j].position.z));
                if (dist < nearest) {
                    nearest = dist;
                    plrid = (str)plrList[j].id;
                }
            }
        }
    }
    return plrid;
}

str[] winList = str[];
bool action playerHasPassed(str playerID) {
    for (num i = 0; i < lengthOf winList; i++) {
        if (winList[i] == playerID) {
            return true;
        }
    }
    return false;
}

str[] RangeList = str[];
bool action playerinRange(str playerID) {
    for (num i = 0; i < lengthOf RangeList; i++) {
        if (RangeList[i] == playerID) {
            return true;
        }
    }
    return false;
}
bool action outRange(str playerID) {
    for (num i = 0; i < lengthOf RangeList; i++) {
        if (RangeList[i] == playerID) {
            remove RangeList[i];
            return true;
        }
    }
    return false;
}

obj[] action findAIbyName(obj[] ailist, str ainame) {
    obj[] aimatchname = obj[];
    for (num i=0; i<lengthOf ailist; i++) {
        if ((str)ailist[i].displayName == ainame) {
            addTo aimatchname (obj) ailist[i];
        }
    }
    return aimatchname;
}


bool gamehappening = false;
bool gamestarted = false;
num tdurationlight = 0;
num tlastlight = 0;
num clocktime = 0;
num tlastclocksync = 0;


action updatelight(num tnow) {
    if (((tnow - tlastlight) > tdurationlight) && (lengthOf markedList == 0)) {
        # GAME.log("updating light");
        tlastlight = tnow;
        if (gamestarted) {
            redlight = redlight ? false : true;
        } else {
            redlight = false;
            gamestarted = true;
            tlastlight = tnow;
            clocktime = MS_CLOCKTIMER;
        }
        
        if (redlight) { # redlight
            doll.playAnim("Back");    
            tdurationlight = UTILS.randInt(MS_MINREDLIGHT,MS_MAXREDLIGHT);
        } else { # greenlight
            tdurationlight = UTILS.randInt(MS_MINGREENLIGHT,MS_MAXGREENLIGHT);
            doll.playAnim("Front"); # play anim
        }
        GAME.NETWORK.broadcast("lightstatus",{redlight:redlight, tdurationlight:tdurationlight});
        
    }
}

action updateRound(num delta) {
    obj[] plrList = GAME.PLAYERS.list();
    if ((tnow - tlastclocksync) > MS_INTERVAL_CLOCKSYNC) {
        if (lengthOf plrList == lengthOf winList) {
            clocktime = 0;
        }
        GAME.NETWORK.broadcast("clocktime",{clocktime:clocktime});
        tlastclocksync = tnow;
    }

    if (clocktime < 0) {
        clocktime = 0;
        gamehappening = false;

        for (num i=0; i< lengthOf plrList; i++) {
            obj player = plrList[i];
            if (playerinRange((str)player.id) || !playerHasPassed((str)player.id)) {
                player.health = 0;
                GAME.NETWORK.broadcast("dead", {player:player.id, x:player.position.x, y:player.position.y, z:player.position.z});
            } else {
                player.position.x = (num)honeycombstart.x;
                player.position.y = (num)honeycombstart.y;
                player.position.z = (num)honeycombstart.z;

            }
        }
    } else {clocktime -= delta;}
}


# Runs when the game starts
public action start() {
	gamehappening = false;
    gamestarted = false;
    redlight = false;
    markedList = str[];
    RangeList = str[];
    ais = GAME.AI.list();
    obj[] dolls = findAIbyName(ais, "doll");
    if (!!dolls) {
        doll = dolls[0];
    } 
    doll.playAnim("Front"); # play anim
}



# Runs every game tick
num tnow = 0;
num tLastDamage = 0;

public action update(num delta) {
	tnow = GAME.TIME.now();
    
    if (gamehappening) {
        updatelight(tnow);
        updateRound(delta);
    }

    obj[] plrList = GAME.PLAYERS.list();
    if (redlight) {addMarks(plrList);} # add new marks each loop

    # shooting people
	if ((lengthOf markedList > 0) && ((tnow - tLastDamage) > MS_FIRERATE)) { # check marked list is not yet empty (and fire rate)
        str plrid = findNearestPlayer((obj)doll.position,markedList, plrList);
        if (!!plrid) {
            obj player = GAME.PLAYERS.findByID(plrid);
            player.health = (num) player.health - GUNDAMAGE;
            tLastDamage = tnow;    
            GAME.NETWORK.broadcast("shoot",{});
            obj[] soldiers = findAIbyName(ais, "soldier");
            for (num i = 0; i < lengthOf soldiers; i++) {
                obj soldier = (obj) soldiers[i];
                soldier.playAnim("Shoot");
            }
            if ((num) player.health <= 0) { # player dead, remove mark
                removeMark((str)player.username);
                GAME.NETWORK.broadcast("dead", {player:plrid, x:player.position.x, y:player.position.y, z:player.position.z});
            }	
        } 
    }
    if (!redlight && (lengthOf markedList == 0)) { # reset player marked list
        markedList = str[];
    }
}

# Player spawns in
public action onPlayerSpawn(str id) {
    outRange(id);
}

# Player update
public action onPlayerUpdate(str id, num delta, static obj inputs) {

}

# Called from Custom Trigger Action
public action onCustomTrigger(str playerID, str customParam) {
	GAME.NETWORK.broadcast(customParam, {});
    if (customParam == "redlight") {
		redlight = true;
	}
	else if (customParam == "greenlight") {
		redlight = false;
	}
    else if (customParam == "inrange") {
        if (!playerinRange(playerID)) {
            addTo RangeList playerID;
            gamehappening = true;
            redlight = false;
        }
    }
    else if (customParam == "outrange") {
        outRange(playerID);
        addTo winList playerID;
    }
    else if (customParam == "leftredgreenroom") {
        GAME.NETWORK.send("leftredgreenroom",{},playerID);
    }
}

# Server receives network message
public action onNetworkMessage(str id, obj data, str playerID) {

}

# Server receives chat message
public action onChatMessage(str msg, str playerID) {

}

# When a player leaves the server
public action onPlayerLeave(str playerID) {
    outRange(playerID);
    removeMark(playerID);
}